/* Generated by re2c 3.0 */
#line 1 "espurna/scheduler_time.re"
/*

Part of SCHEDULER MODULE

Copyright (C) 2017 by faina09
Adapted by Xose PÃ©rez <xose dot perez at gmail dot com>

Copyright (C) 2019-2024 by Maxim Prokhorov <prokhorov dot max at outlook dot com>

*/

#pragma once

#include "datetime.h"
#include "types.h"
#include "utils.h"

#include "scheduler_common.ipp"

namespace espurna {
namespace scheduler {
namespace {

// Heavily inspired by systemd.time OnCalendar= syntax
// https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html#Calendar%20Events
//
// Most specs should work, but there are some differences
// - there are no year ranges here (pending a better idea of range/repetetion algo)
// - '-L' instead of '~' for last-day-of-month
// - '-W' syntax for weeks aka 'day-index'
// - ranges *can* loop around - Fri..Tue 10:55..05 is valid, but still means the same hour and not 11:00..05

namespace parse {

// special out-of-bounds day for parsed value validation
constexpr auto InvalidDay = datetime::Weekday{ 7 };

// date or time ANY value
constexpr bool is_any(StringView view) {
    return view.length() == 1 && '*' == view[0];
}

// date day-of-week N counted backwards
constexpr bool is_last(StringView view) {
    return view.length() == 1 && ('l' == view[0] || 'L' == view[0]);
}

// Nth week of the month
constexpr bool is_weekday_index(StringView view) {
    return view.length() == 2 && ('W' == view[0] || 'w' == view[0]);
}

constexpr int dec_char2int(char c) {
    return (('0' <= c) && (c <= '9'))
        ? (c - '0') : -1;
}

bool fill_bit_range(bits::Range& range, StringView view) {
    const char* YYCURSOR { view.begin() };
    const char* YYLIMIT { view.end() };

    bool done { false };
    bool out { false };

    auto last = -1;
    auto range_last = -1;

    ParseUnsignedResult result;
    int repeat { -1 };

    const char* p { nullptr };

loop:
    
#line 78 "espurna/scheduler_time.re.ipp"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
		case ',': goto yy3;
		case '.': goto yy4;
		case '/': goto yy5;
		case '0' ... '9': goto yy6;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy10;
			goto yy1;
	}
yy1:
	++YYCURSOR;
yy2:
#line 110 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 99 "espurna/scheduler_time.re.ipp"
yy3:
	++YYCURSOR;
#line 101 "espurna/scheduler_time.re"
	{
        goto consume_last;
      }
#line 106 "espurna/scheduler_time.re.ipp"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
		case '.': goto yy7;
		default: goto yy2;
	}
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0' ... '9': goto yy8;
		default: goto yy2;
	}
yy6:
	++YYCURSOR;
#line 83 "espurna/scheduler_time.re"
	{
        goto take_last;
      }
#line 125 "espurna/scheduler_time.re.ipp"
yy7:
	++YYCURSOR;
#line 97 "espurna/scheduler_time.re"
	{
        goto take_range;
      }
#line 132 "espurna/scheduler_time.re.ipp"
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0' ... '9': goto yy8;
		default: goto yy9;
	}
yy9:
#line 87 "espurna/scheduler_time.re"
	{
        p = YYCURSOR - 1;
        while (*p != '/') {
          --p;
        }
        ++p;

        goto take_repeat;
      }
#line 150 "espurna/scheduler_time.re.ipp"
yy10:
#line 105 "espurna/scheduler_time.re"
	{
        done = true;
        goto consume_last;
      }
#line 157 "espurna/scheduler_time.re.ipp"
}
#line 115 "espurna/scheduler_time.re"


// update {last} with the latest digit
take_last:
    if (last == -1) {
      last = 0;
    }

    last = (last * 10) + (*(YYCURSOR - 1) - '0');
    goto loop;

// map every nth bit, based on repeat value
take_repeat:
    if (last == -1) {
        out = false;
        goto return_out;
    }

    if (repeat != -1) {
        out = false;
        goto return_out;
    }

    result = parseUnsigned(StringView(p, YYCURSOR), 10);
    if (!result.ok) {
        out = false;
        goto return_out;
    }

    repeat = result.value;

    goto consume_last;

// expect {last} to be set, bail otherwise
take_range:
    if (last == -1) {
        out = false;
        goto return_out;
    }

    range_last = last;
    last = -1;

    goto loop;

consume_last:
    // validate w/ range
    if ((last != -1) && !range.valid(last)) {
        out = false;
        goto return_out;
    }

    // in case repeat is set for a single value, set {last} to the last possible bit
    if ((range_last == -1) && (repeat > 0)) {
        range_last = last;
        last = range.end();
    }

    // fill output with {range_last}..{last} within range boundaries
    // bitset should support roll over for when {last} is less than {range_last}
    // meaning, 45..15 <=> 0..15,45..63. otherwise, support the usual 0..63
    // all bits between x and y, also including x and y, are set (i.e. range is inclusive)
    if ((last != -1) && (range_last != -1)) {
        range.fill(range_last, last, (repeat > 0) ? repeat : 1);
        out = true;
    // return immediately when there was no {last} after {range_last} was set
    } else if (range_last != -1) {
        done = true;
        out = false;
    // everything is ok, set and consume {last} bit
    } else if (last != -1) {
        range.set(last);
        out = true;
    // no need to continue, return current state
    } else {
        done = true;
    }

    if (done) {
        goto return_out;
    }

    last = range_last = -1;
    repeat = -1;

    goto loop;

return_out:
    return out;
}

// monday,wednesday / mon...fri / 1,2,3 / mon,2
// numeric value is 1..7, starting from monday
// both short and full forms are allowed
// (which can be either in upper or lower case, or mixed)
bool parse_weekdays(WeekdayMatch& match, StringView view) {

    const char* YYCURSOR { view.begin() };
    const char* YYLIMIT { view.end() };
    const char* YYMARKER;

    bool done { false };
    bool out { false };

    auto current = InvalidDay;

    auto last = InvalidDay;
    auto range_last = InvalidDay;

loop:
    
#line 271 "espurna/scheduler_time.re.ipp"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case ',': goto yy14;
		case '.': goto yy15;
		case '1': goto yy16;
		case '2': goto yy18;
		case '3': goto yy20;
		case '4': goto yy22;
		case '5': goto yy24;
		case '6': goto yy26;
		case '7': goto yy28;
		case 'F':
		case 'f': goto yy30;
		case 'M':
		case 'm': goto yy31;
		case 'S':
		case 's': goto yy32;
		case 'T':
		case 't': goto yy33;
		case 'W':
		case 'w': goto yy34;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy73;
			goto yy12;
	}
yy12:
	++YYCURSOR;
yy13:
#line 291 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 308 "espurna/scheduler_time.re.ipp"
yy14:
	++YYCURSOR;
#line 281 "espurna/scheduler_time.re"
	{
        out = false;
        goto consume_last;
      }
#line 316 "espurna/scheduler_time.re.ipp"
yy15:
	yych = *++YYCURSOR;
	switch (yych) {
		case '.': goto yy35;
		default: goto yy13;
	}
yy16:
	++YYCURSOR;
yy17:
#line 241 "espurna/scheduler_time.re"
	{
        current = datetime::Monday;
        goto take_last;
      }
#line 331 "espurna/scheduler_time.re.ipp"
yy18:
	++YYCURSOR;
yy19:
#line 246 "espurna/scheduler_time.re"
	{
        current = datetime::Tuesday;
        goto take_last;
      }
#line 340 "espurna/scheduler_time.re.ipp"
yy20:
	++YYCURSOR;
yy21:
#line 251 "espurna/scheduler_time.re"
	{
        current = datetime::Wednesday;
        goto take_last;
      }
#line 349 "espurna/scheduler_time.re.ipp"
yy22:
	++YYCURSOR;
yy23:
#line 256 "espurna/scheduler_time.re"
	{
        current = datetime::Thursday;
        goto take_last;
      }
#line 358 "espurna/scheduler_time.re.ipp"
yy24:
	++YYCURSOR;
yy25:
#line 261 "espurna/scheduler_time.re"
	{
        current = datetime::Friday;
        goto take_last;
      }
#line 367 "espurna/scheduler_time.re.ipp"
yy26:
	++YYCURSOR;
yy27:
#line 266 "espurna/scheduler_time.re"
	{
        current = datetime::Saturday;
        goto take_last;
      }
#line 376 "espurna/scheduler_time.re.ipp"
yy28:
	++YYCURSOR;
yy29:
#line 271 "espurna/scheduler_time.re"
	{
        current = datetime::Sunday;
        goto take_last;
      }
#line 385 "espurna/scheduler_time.re.ipp"
yy30:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'R':
		case 'r': goto yy36;
		default: goto yy13;
	}
yy31:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O':
		case 'o': goto yy38;
		default: goto yy13;
	}
yy32:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'A':
		case 'a': goto yy39;
		case 'U':
		case 'u': goto yy40;
		default: goto yy13;
	}
yy33:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'H':
		case 'h': goto yy41;
		case 'U':
		case 'u': goto yy42;
		default: goto yy13;
	}
yy34:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'E':
		case 'e': goto yy43;
		default: goto yy13;
	}
yy35:
	++YYCURSOR;
#line 276 "espurna/scheduler_time.re"
	{
        out = false;
        goto take_range;
      }
#line 437 "espurna/scheduler_time.re.ipp"
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy44;
		default: goto yy37;
	}
yy37:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
		case 0: goto yy13;
		case 1: goto yy25;
		case 2: goto yy17;
		case 3: goto yy27;
		case 4: goto yy29;
		case 5: goto yy23;
		case 6: goto yy19;
		default: goto yy21;
	}
yy38:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy45;
		default: goto yy37;
	}
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy46;
		default: goto yy37;
	}
yy40:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy47;
		default: goto yy37;
	}
yy41:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'U':
		case 'u': goto yy48;
		default: goto yy37;
	}
yy42:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy49;
		default: goto yy37;
	}
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy50;
		default: goto yy37;
	}
yy44:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'D':
		case 'd': goto yy51;
		default: goto yy25;
	}
yy45:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'D':
		case 'd': goto yy52;
		default: goto yy17;
	}
yy46:
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'U':
		case 'u': goto yy53;
		default: goto yy27;
	}
yy47:
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'D':
		case 'd': goto yy54;
		default: goto yy29;
	}
yy48:
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'R':
		case 'r': goto yy55;
		default: goto yy23;
	}
yy49:
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'S':
		case 's': goto yy56;
		default: goto yy19;
	}
yy50:
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'N':
		case 'n': goto yy57;
		default: goto yy21;
	}
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy58;
		default: goto yy37;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy59;
		default: goto yy37;
	}
yy53:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy60;
		default: goto yy37;
	}
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy61;
		default: goto yy37;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy62;
		default: goto yy37;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy63;
		default: goto yy37;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy64;
		default: goto yy37;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy24;
		default: goto yy37;
	}
yy59:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy16;
		default: goto yy37;
	}
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy65;
		default: goto yy37;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy28;
		default: goto yy37;
	}
yy62:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy66;
		default: goto yy37;
	}
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy67;
		default: goto yy37;
	}
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy68;
		default: goto yy37;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy69;
		default: goto yy37;
	}
yy66:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy70;
		default: goto yy37;
	}
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy18;
		default: goto yy37;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy71;
		default: goto yy37;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy26;
		default: goto yy37;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy22;
		default: goto yy37;
	}
yy71:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'A':
		case 'a': goto yy72;
		default: goto yy37;
	}
yy72:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy20;
		default: goto yy37;
	}
yy73:
#line 286 "espurna/scheduler_time.re"
	{
        done = true;
        goto consume_last;
      }
#line 715 "espurna/scheduler_time.re.ipp"
}
#line 296 "espurna/scheduler_time.re"


// process pending token, bail when seeing duplicates or errors
take_last:
    if ((current == InvalidDay) || (last != InvalidDay)) {
        out = false;
        goto return_out;
    }

    last = current;
    current = InvalidDay;

    goto loop;

// expect {last} to be set, bail otherwise
take_range:
    if (last != InvalidDay) {
        range_last = last;
        last = InvalidDay;
        goto loop;
    }

    goto return_out;

consume_last:
    // fill output with {range_last}..{last}
    // similar to generic range parser, support inverse fill
    // no /{repeat}, though, but this is the shortest range
    if ((last != InvalidDay) && (range_last != InvalidDay)) {
        match |= fill_match(range_last, last);
        out = true;
    // return immediately in case no {range_last} was provided
    } else if (range_last != InvalidDay) {
        done = true;
        out = false;
    // otherwise, just set the previouly updated {last}
    } else if (last != InvalidDay) {
        match |= last;
        out = true;
    // return the results gathered so far
    } else {
        done = true;
    }

    if (done) {
        goto return_out;
    }

    last = range_last = InvalidDay;

    goto loop;

return_out:
    return out && (YYCURSOR == YYLIMIT);
}

bool update_year(DateMatch& match, StringView view) {
    if (is_any(view)) {
        match.year = 0;
        return true;
    }

    auto result = parseUnsigned(view, 10);
    if (result.ok && (result.value >= 1970)) {
        match.year = result.value;
        return true;
    }

    return false;
}

bool update_month(DateMatch& match, StringView view) {
    if (is_any(view)) {
        match.month.set();
        return true;
    }

    auto range = bits::Range{1, 12};
    if (fill_bit_range(range, view)) {
        match.month = range.to_u32() >> 1;
        return true;
    }

    return false;
}

bool update_day_of_week(DateMatch& match, StringView view) {
    if (is_any(view)) {
        match.day.set();
        match.day[0] = false;
        return true;
    }

    auto range = bits::Range{1, 31};
    if (fill_bit_range(range, view)) {
        match.day = range.to_u32();
        return true;
    }

    return false;
}

bool update_weekday_index(DateMatch& match, StringView view) {
    if ((view[1] == 'L') || (view[1] == 'l')) {
        match.day_index[0] = true;
        return true;
    }

    auto index = dec_char2int(view[1]);
    if ((index >= 1) && (index <= 5)) {
        match.day_index[index] = true;
        return true;
    }

    return false;
}

bool update_weekday_last(DateMatch& match, StringView view) {
    match.day[0] = true;

    if (view.length() == 1) {
        return true;
    }

    view = StringView(view.begin() + 1, view.end());

    auto range = bits::Range{1, 31};
    if (fill_bit_range(range, view)) {
        match.day |= range.to_u32();
        return true;
    }

    return false;
}

bool parse_date(DateMatch& match, StringView view) {
    const char* YYCURSOR { view.begin() };
    const char* YYLIMIT { view.end() };
    const char* YYMARKER;

    StringView tmp;
    bool out { false };

    const char *p;

    
#line 864 "espurna/scheduler_time.re.ipp"
enum YYCONDTYPE {
	yycinit,
	yycyyyy_mm_dd,
	yycmm_dd
};
#line 441 "espurna/scheduler_time.re"

    int c = yycinit;

    
#line 875 "espurna/scheduler_time.re.ipp"
const char *yyt1;const char *yyt2;
#line 444 "espurna/scheduler_time.re"


    // {yyyy} - single number for year (todo? u64 mask should cover 2024..2088)
    // {mm} - month. single number, comma-separated numbers or numeric range
    // {dow} - day-of-week. single number, comma-separated numbers or numeric range
    // {wdi} - weekday-index. single number for Nth weekday in the month.
    // {wdl} - weekday-last. same as {dow}, but starting from the end of the month

    // using common format of {yyyy}-{mm}-{dd}, with optional {yyyy}
    // with {wdl}, L{N} used instead of replacing hyphen with ~{N} like systemd calendar does

    // note the ambigous [*]-MM-DD / [*]-DD match, using lookahead to work around that

    
#line 892 "espurna/scheduler_time.re.ipp"
{
	char yych;
	unsigned int yyaccept = 0;
	switch (c) {
		case yycinit: goto yyc_init;
		case yycyyyy_mm_dd: goto yyc_yyyy_mm_dd;
		case yycmm_dd: goto yyc_mm_dd;
	}
/* *********************************** */
yyc_init:
	yych = *YYCURSOR;
	switch (yych) {
		case '*':
			yyt1 = YYCURSOR;
			goto yy77;
		case ',':
		case '.' ... '/':
			yyt1 = YYCURSOR;
			goto yy78;
		case '0' ... '9':
			yyt1 = YYCURSOR;
			goto yy79;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy99;
			goto yy75;
	}
yy75:
	++YYCURSOR;
yy76:
#line 519 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 927 "espurna/scheduler_time.re.ipp"
yy77:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '-':
			yyt2 = YYCURSOR;
			goto yy80;
		default: goto yy76;
	}
yy78:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ',' ... '9': goto yy83;
		default: goto yy76;
	}
yy79:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ',' ... '/': goto yy83;
		case '0' ... '9': goto yy85;
		default: goto yy76;
	}
yy80:
	yych = *++YYCURSOR;
	switch (yych) {
		case '*': goto yy86;
		case ',':
		case '.' ... '9': goto yy88;
		case 'L':
		case 'l': goto yy89;
		case 'W':
		case 'w': goto yy90;
		default: goto yy81;
	}
yy81:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy76;
	} else {
		goto yy87;
	}
yy82:
	yych = *++YYCURSOR;
yy83:
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy82;
		case '-':
			yyt2 = YYCURSOR;
			goto yy84;
		default: goto yy81;
	}
yy84:
	yych = *++YYCURSOR;
	switch (yych) {
		case '*': goto yy91;
		case ',':
		case '.' ... '9':
		case 'L':
		case 'l': goto yy89;
		case 'W':
		case 'w': goto yy90;
		default: goto yy81;
	}
yy85:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy81;
		case '0' ... '9': goto yy92;
		default: goto yy83;
	}
yy86:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '-': goto yy93;
		default: goto yy87;
	}
yy87:
	p = yyt1;
	YYCURSOR = yyt2;
	c = yycmm_dd;
#line 490 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        if (!update_month(match, tmp)) {
          goto return_out;
        }

        ++YYCURSOR;

        goto yyc_mm_dd;
      }
#line 1023 "espurna/scheduler_time.re.ipp"
yy88:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy88;
		case '-': goto yy93;
		default: goto yy87;
	}
yy89:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy89;
		default: goto yy87;
	}
yy90:
	yych = *++YYCURSOR;
	switch (yych) {
		case '1' ... '5':
		case 'L':
		case 'l': goto yy91;
		default: goto yy81;
	}
yy91:
	++YYCURSOR;
	goto yy87;
yy92:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy81;
		case '0' ... '9': goto yy94;
		default: goto yy83;
	}
yy93:
	yych = *++YYCURSOR;
	switch (yych) {
		case '*': goto yy95;
		case ',':
		case '.' ... '9':
		case 'L':
		case 'l': goto yy97;
		case 'W':
		case 'w': goto yy98;
		default: goto yy81;
	}
yy94:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy81;
		case '-':
			yyt2 = YYCURSOR;
			goto yy80;
		default: goto yy83;
	}
yy95:
	++YYCURSOR;
yy96:
	p = yyt1;
	YYCURSOR = yyt2;
	c = yycyyyy_mm_dd;
#line 479 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        if (!update_year(match, tmp)) {
          goto return_out;
        }

        ++YYCURSOR;

        goto yyc_yyyy_mm_dd;
      }
#line 1096 "espurna/scheduler_time.re.ipp"
yy97:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy97;
		default: goto yy96;
	}
yy98:
	yych = *++YYCURSOR;
	switch (yych) {
		case '1' ... '5':
		case 'L':
		case 'l': goto yy95;
		default: goto yy81;
	}
yy99:
#line 524 "espurna/scheduler_time.re"
	{
        goto return_out;
      }
#line 1117 "espurna/scheduler_time.re.ipp"
/* *********************************** */
yyc_yyyy_mm_dd:
	yych = *YYCURSOR;
	switch (yych) {
		case '*':
			yyt1 = YYCURSOR;
			goto yy103;
		case ',':
		case '.' ... '9':
			yyt1 = YYCURSOR;
			goto yy104;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy113;
			goto yy101;
	}
yy101:
	++YYCURSOR;
yy102:
#line 519 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 1141 "espurna/scheduler_time.re.ipp"
yy103:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '-':
			yyt2 = YYCURSOR;
			goto yy105;
		default: goto yy102;
	}
yy104:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ',' ... '9': goto yy108;
		default: goto yy102;
	}
yy105:
	yych = *++YYCURSOR;
	switch (yych) {
		case '*': goto yy109;
		case ',':
		case '.' ... '9':
		case 'L':
		case 'l': goto yy111;
		case 'W':
		case 'w': goto yy112;
		default: goto yy106;
	}
yy106:
	YYCURSOR = YYMARKER;
	goto yy102;
yy107:
	yych = *++YYCURSOR;
yy108:
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy107;
		case '-':
			yyt2 = YYCURSOR;
			goto yy105;
		default: goto yy106;
	}
yy109:
	++YYCURSOR;
yy110:
	p = yyt1;
	YYCURSOR = yyt2;
	c = yycmm_dd;
#line 490 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        if (!update_month(match, tmp)) {
          goto return_out;
        }

        ++YYCURSOR;

        goto yyc_mm_dd;
      }
#line 1199 "espurna/scheduler_time.re.ipp"
yy111:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy111;
		default: goto yy110;
	}
yy112:
	yych = *++YYCURSOR;
	switch (yych) {
		case '1' ... '5':
		case 'L':
		case 'l': goto yy109;
		default: goto yy106;
	}
yy113:
#line 524 "espurna/scheduler_time.re"
	{
        goto return_out;
      }
#line 1220 "espurna/scheduler_time.re.ipp"
/* *********************************** */
yyc_mm_dd:
	yych = *YYCURSOR;
	switch (yych) {
		case '*':
			yyt1 = YYCURSOR;
			goto yy117;
		case ',':
		case '.' ... '9':
			yyt1 = YYCURSOR;
			goto yy119;
		case 'L':
		case 'l':
			yyt1 = YYCURSOR;
			goto yy120;
		case 'W':
		case 'w': goto yy122;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy124;
			goto yy115;
	}
yy115:
	++YYCURSOR;
yy116:
#line 519 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 1250 "espurna/scheduler_time.re.ipp"
yy117:
	++YYCURSOR;
yy118:
	p = yyt1;
#line 501 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        out = update_day_of_week(match, tmp);
        goto return_out;
      }
#line 1261 "espurna/scheduler_time.re.ipp"
yy119:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy119;
		default: goto yy118;
	}
yy120:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy120;
		default: goto yy121;
	}
yy121:
	p = yyt1;
#line 513 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        out = update_weekday_last(match, tmp);
        goto return_out;
      }
#line 1284 "espurna/scheduler_time.re.ipp"
yy122:
	yych = *++YYCURSOR;
	switch (yych) {
		case '1' ... '5':
		case 'L':
		case 'l': goto yy123;
		default: goto yy116;
	}
yy123:
	++YYCURSOR;
	p = YYCURSOR - 2;
#line 507 "espurna/scheduler_time.re"
	{
        tmp = StringView(p, YYCURSOR - p);
        out = update_weekday_index(match, tmp);
        goto return_out;
      }
#line 1302 "espurna/scheduler_time.re.ipp"
yy124:
#line 524 "espurna/scheduler_time.re"
	{
        goto return_out;
      }
#line 1308 "espurna/scheduler_time.re.ipp"
}
#line 528 "espurna/scheduler_time.re"


return_out:
    return out && (YYCURSOR == YYLIMIT);
}

bool update_hour(TimeMatch& match, StringView view) {
    if (is_any(view)) {
        match.hour.set();
        return true;
    }

    auto range = bits::Range{0, 23};
    if (fill_bit_range(range, view)) {
        match.hour = range.to_u32();
        return true;
    }

    return false;
}

bool update_minute(TimeMatch& match, StringView view) {
    if (is_any(view)) {
        match.minute.set();
        return true;
    }

    auto range = bits::Range{0, 60};
    if (fill_bit_range(range, view)) {
        match.minute = range.to_u64();
        return true;
    }

    return false;
}

// *:15 - every 15th minute of an hour
// 15:* - every minute of 15th hour
// *:*  - every minute
//
// 0/5:00  - 00:00, 05:00, 10:00, 15:00, 20:00
// *:0/30  - 00:30, 01:00, 01:30, etc.
bool parse_time(TimeMatch& match, StringView view) {
    const char* YYCURSOR { view.begin() };
    const char* YYLIMIT { view.end() };
    const char* YYMARKER;

    StringView tmp;
    bool out { false };

    const char *h0;
    const char *h1;

    const char *m0;

    
#line 1367 "espurna/scheduler_time.re.ipp"
const char *yyt1;const char *yyt2;
#line 583 "espurna/scheduler_time.re"


loop:
    
#line 1374 "espurna/scheduler_time.re.ipp"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
		case '*':
			yyt1 = YYCURSOR;
			goto yy128;
		case ',':
		case '.' ... '9':
			yyt1 = YYCURSOR;
			goto yy129;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy137;
			goto yy126;
	}
yy126:
	++YYCURSOR;
yy127:
#line 617 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 1398 "espurna/scheduler_time.re.ipp"
yy128:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ':': goto yy130;
		default: goto yy127;
	}
yy129:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case ',':
		case '.' ... ':': goto yy133;
		default: goto yy127;
	}
yy130:
	yych = *++YYCURSOR;
	switch (yych) {
		case '*':
			yyt2 = YYCURSOR;
			goto yy134;
		case ',':
		case '.' ... '9':
			yyt2 = YYCURSOR;
			goto yy136;
		default: goto yy131;
	}
yy131:
	YYCURSOR = YYMARKER;
	goto yy127;
yy132:
	yych = *++YYCURSOR;
yy133:
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy132;
		case ':': goto yy130;
		default: goto yy131;
	}
yy134:
	++YYCURSOR;
yy135:
	h0 = yyt1;
	m0 = yyt2;
	h1 = yyt2 - 1;
#line 601 "espurna/scheduler_time.re"
	{
        tmp = StringView(h0, h1 - h0);
        if (!update_hour(match, tmp)) {
          goto return_out;
        }

        tmp = StringView(m0, YYCURSOR - m0);
        if (!update_minute(match, tmp)) {
          goto return_out;
        }

        out = true;

        goto loop;
      }
#line 1458 "espurna/scheduler_time.re.ipp"
yy136:
	yych = *++YYCURSOR;
	switch (yych) {
		case ',':
		case '.' ... '9': goto yy136;
		default: goto yy135;
	}
yy137:
#line 622 "espurna/scheduler_time.re"
	{
        goto return_out;
      }
#line 1471 "espurna/scheduler_time.re.ipp"
}
#line 625 "espurna/scheduler_time.re"


return_out:
    return out && (YYCURSOR == YYLIMIT);
}

// Extra conditions, generally set through keywords
bool parse_time_keyword(TimeMatch& match, StringView view) {
    const char* YYCURSOR { view.begin() };
    const char* YYLIMIT { view.end() };
    const char* YYMARKER;

    bool out { false };

loop:
    
#line 1490 "espurna/scheduler_time.re.ipp"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy141;
		case 'U':
		case 'u': goto yy142;
		default:
			if (YYLIMIT <= YYCURSOR) goto yy155;
			goto yy139;
	}
yy139:
	++YYCURSOR;
yy140:
#line 670 "espurna/scheduler_time.re"
	{
        out = false;
        goto return_out;
      }
#line 1511 "espurna/scheduler_time.re.ipp"
yy141:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'U':
		case 'u': goto yy143;
		default: goto yy140;
	}
yy142:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'T':
		case 't': goto yy145;
		default: goto yy140;
	}
yy143:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy146;
		default: goto yy144;
	}
yy144:
	YYCURSOR = YYMARKER;
	goto yy140;
yy145:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'C':
		case 'c': goto yy147;
		default: goto yy144;
	}
yy146:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy148;
		case 'S':
		case 's': goto yy149;
		default: goto yy144;
	}
yy147:
	++YYCURSOR;
#line 664 "espurna/scheduler_time.re"
	{
        match.flags |= FlagUtc;
        out = true;
        goto loop;
      }
#line 1560 "espurna/scheduler_time.re.ipp"
yy148:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy150;
		default: goto yy144;
	}
yy149:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy151;
		default: goto yy144;
	}
yy150:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy152;
		default: goto yy144;
	}
yy151:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy153;
		default: goto yy144;
	}
yy152:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'E':
		case 'e': goto yy154;
		default: goto yy144;
	}
yy153:
	++YYCURSOR;
#line 658 "espurna/scheduler_time.re"
	{
        match.flags |= FlagSunset;
        out = true;
        goto loop;
      }
#line 1604 "espurna/scheduler_time.re.ipp"
yy154:
	++YYCURSOR;
#line 652 "espurna/scheduler_time.re"
	{
        match.flags |= FlagSunrise;
        out = true;
        goto loop;
      }
#line 1613 "espurna/scheduler_time.re.ipp"
yy155:
#line 675 "espurna/scheduler_time.re"
	{
        goto return_out;
      }
#line 1619 "espurna/scheduler_time.re.ipp"
}
#line 678 "espurna/scheduler_time.re"


return_out:
    return out && (YYCURSOR == YYLIMIT);
}

} // namespace parse

using parse::parse_date;
using parse::parse_weekdays;
using parse::parse_time;
using parse::parse_time_keyword;

Schedule parse_schedule(StringView view) {
    Schedule out;

    // DATE " " WDS " " TIME " " KW
    const auto spaces = std::count(view.begin(), view.end(), ' ');
    if (spaces > 3) {
        return out;
    }

    auto split = SplitStringView(view);

    bool parsed_date { false };
    bool parsed_weekdays { false };
    bool parsed_time { false };
    bool parsed_keyword { false };

    int parsed { 0 };

    while (split.next()) {
        auto elem = split.current();

        // most expected order, starting with date
        if (!parsed_date && ((parsed_date = parse_date(out.date, elem)))) {
            ++parsed;
            continue;
        }

        // then weekdays
        if (!parsed_weekdays && ((parsed_weekdays = parse_weekdays(out.weekdays, elem)))) {
            ++parsed;
            continue;
        }

        // then time
        if (!parsed_time && ((parsed_time = parse_time(out.time, elem)))) {
            ++parsed;
            continue;
        }

        // and keyword is always at the end. forcibly stop the parsing, regardless of the state
        if ((parsed_keyword = parse_time_keyword(out.time, elem))) {
            ++parsed;
            break;
        }
    }

    // expect one of each element, plus optional keyword
    if (parsed != (1 + spaces)) {
        return out;
    }

    // do not want both time and sun{rise,set}
    if (want_sunrise_sunset(out.time) && parsed_time) {
        return out;
    }

    out.ok = parsed_date
        || parsed_weekdays
        || parsed_time
        || parsed_keyword;

    if (out.ok && !parsed_time && !want_sunrise_sunset(out.time)) {
        out.time.hour = 0b1;
        out.time.minute = 0b1;
    }

    return out;
}

} // namespace
} // namespace scheduler
} // namespace espurna
